import { routerActions, RouterState } from "connected-react-router";
import { History, LocationDescriptorObject } from "history";
import createHistory from "history/createBrowserHistory";
import { ComponentType } from "react";
import { Action, Middleware, ReducersMapObject } from "redux";
import { buildModel } from "./buildModel";
import { delay, SagaIterator } from "redux-saga";
import { call, CallEffect, cps, fork, put, take } from "redux-saga/effects";
import { ERROR_ACTION_NAME, INIT_LOCATION_ACTION_NAME, INIT_MODULE_ACTION_NAME, LOADING_ACTION_NAME, LOCATION_CHANGE_ACTION_NAME, NSP } from "./actions";
import buildApp from "./Application";
import { injectActions, injectHandlers } from "./inject";
import { asyncComponent } from "./asyncImport";

import { LoadingState, setActions, setLoading, setLoadingDepthTime } from "./loading";
import { buildStore, getModuleState, getRootState, getSagaNames, getSingleStore } from "./storeProxy";
import { BaseModuleState, Model, StoreState, ActionHandlerList } from "./types";
import { delayPromise, setGenerator } from "./utils";

let prvHistory: History;
const hasInjected: { [moduleName: string]: boolean } = {};
const injectedModules: Array<{ type: string }> = [];

const actionsProxy: { [moduleName: string]: { [action: string]: Function } } = {};

setActions(actionsProxy);

export function getStore() {
  // redux3中Store泛型有一个参数，redux4中变为2个，为兼容此处设为any
  return getSingleStore() as any;
}
export function getHistory() {
  return prvHistory;
}
export function createApp(view: ComponentType<any>, container: string, storeMiddlewares: Middleware[] = [], storeEnhancers: Function[] = [], reducers: ReducersMapObject = {}, storeHistory?: History) {
  prvHistory = storeHistory || createHistory();
  const store = buildStore(prvHistory, reducers, storeMiddlewares, storeEnhancers, injectedModules);
  buildApp(view, container, storeMiddlewares, storeEnhancers, store, prvHistory);
}

export interface Model<S> {
  namespace: string;
  actions: ActionHandlerList<S>;
  handlers: ActionHandlerList<S>;
}

export function buildViews<T>(views: T, model: Model<any>) {
  const namespace = model.namespace;
  if (!hasInjected[namespace]) {
    const locationChangeHandler = model.handlers[LOCATION_CHANGE_ACTION_NAME];
    if (locationChangeHandler) {
      model.handlers[namespace + NSP + INIT_LOCATION_ACTION_NAME] = locationChangeHandler;
    }
    const actionList = injectActions(namespace, model.actions);
    injectHandlers(namespace, model.handlers);
    const actions = getModuleActions(namespace);
    Object.keys(actionList).forEach(key => {
      actions[key] = payload => ({ type: namespace + NSP + key, payload });
    });
    hasInjected[namespace] = true;
    const action = actions[INIT_MODULE_ACTION_NAME]();
    const store = getSingleStore();
    if (store) {
      store.dispatch(action);
    } else {
      injectedModules.push(action);
    }
    return views;
  } else {
    throw new Error(`module: ${namespace} has exist!`);
  }
}
function getModuleActions(namespace: string) {
  const actions = actionsProxy[namespace] || {};
  actionsProxy[namespace] = actions;
  return actions;
}
export function buildModule<T>(namespace: string) {
  const actions: T = getModuleActions(namespace) as any;
  // if (window["Proxy"]) {
  //   actions = new window["Proxy"](
  //     {},
  //     {
  //       get: (target: {}, key: string) => {
  //         return (data: any) => ({ type: namespace + "/" + key, data });
  //       }
  //     }
  //   );
  // } else {
  //   actions = getModuleActions(namespace) as any;
  // }
  return {
    namespace,
    actions,
  };
}

export { buildModel };

export { Action, LocationDescriptorObject, StoreState, BaseModuleState, RouterState };
export { asyncComponent, setLoadingDepthTime, setLoading, LoadingState, delayPromise, getSagaNames };
export { ERROR_ACTION_NAME, LOCATION_CHANGE_ACTION_NAME };
export { call, put };
